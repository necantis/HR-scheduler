# -*- coding: utf-8 -*-
"""HR_Scheduling with Github.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1KhTmrJkw043HKJIJ3Kz2eE3Wai_Ou-rP
"""

import gspread
from oauth2client.service_account import ServiceAccountCredentials
import pandas as pd
from datetime import datetime, timedelta, date
import calendar
from ortools.sat.python import cp_model
import uuid
import imaplib
import email
import time

# --- MODULE 1: GOOGLE SHEETS CONNECTION & DATA READING ---

def connect_to_sheet():
    """Connects to the Google Sheet."""
    try:
        scope = ['https://spreadsheets.google.com/feeds', 'https://www.googleapis.com/auth/drive']
        creds = ServiceAccountCredentials.from_json_keyfile_name('creds.json', scope)
        client = gspread.authorize(creds)
        spreadsheet = client.open('2025_HR Planner')
        print("✅ Successfully connected to the Google Sheet.")
        return spreadsheet
    except Exception as e:
        print(f"❌ Error connecting to Google Sheet: {e}")
        return None

def read_data(sheet):
    """Reads all required data from the Google Sheet into DataFrames."""
    print("Reading data from all tabs...")
    employees_ws = sheet.worksheet("Employees")
    employees_df = pd.DataFrame(employees_ws.get_all_records())

    shifts_ws = sheet.worksheet("Shifts")
    shifts_df = pd.DataFrame(shifts_ws.get_all_records())

    requests_ws = sheet.worksheet("Absence_Requests")
    requests_df = pd.DataFrame(requests_ws.get_all_records())
    if not requests_df.empty:
        # Use the new French column names "Début" and "Fin"
        requests_df = requests_df.rename(columns={
            "Nom": "Employee_Name",
            "Début": "Start_Date",
            "Fin": "End_Date",
            "Tokens": "Tokens_Bid"
        })
    
    official_schedule_ws = sheet.worksheet("Official_Schedule")
    official_schedule_df = pd.DataFrame(official_schedule_ws.get_all_records())

    return employees_df, shifts_df, requests_df, official_schedule_df

# --- MODULE 2: SCHEDULING LOGIC (OR-TOOLS) ---

def generate_schedule(employees_df, shifts_df, requests_df, official_schedule_df):
    """
    Generates a schedule with ALL features: dynamic dates, multi-day requests,
    locking past days, and using the official schedule as a hint.
    """
    print("--- Starting Schedule Generation (Full-Featured) ---")

    # --- MERGED: Dynamic Date & Multi-Day Request Logic ---
    today = datetime.now()
    _, num_days = calendar.monthrange(today.year, today.month)
    today_index = today.day - 1
    print(f"✅ Detected {num_days} days for the current month. Locking all days up to and including Day {today.day}.")

    requests = []
    if not requests_df.empty:
        for _, row in requests_df.iterrows():
            start_date = pd.to_datetime(row['Start_Date'], dayfirst=True)
            end_date = pd.to_datetime(row['End_Date'], dayfirst=True)
            num_request_days = (end_date - start_date).days + 1
            tokens_per_day = row['Tokens_Bid'] // num_request_days if num_request_days > 0 else 0
            for day_delta in range(num_request_days):
                current_date = start_date + timedelta(days=day_delta)
                requests.append((row['Employee_Name'], current_date.day, 'OFF', tokens_per_day))

    # (The rest of the data prep remains the same)
    all_employees = employees_df['Employee_Name'].tolist()
    employees = {'Infirmier': [], 'Intérimaire': []}
    for _, row in employees_df.iterrows():
        name, role = row['Employee_Name'], row['Role']
        if role in employees: employees[role].append(name)

    shifts = {}
    for _, row in shifts_df.iterrows():
        shift_id = row['Shift_ID']
        applicable_days = [int(day) for day in str(row['Applicable_Days'])]
        shifts[shift_id] = {'duration': int(row['Duration_Hours'] * 100), 'role': row['Role'], 'days': applicable_days}
    
    days_of_week = [d % 7 for d in range(num_days)]
    model = cp_model.CpModel()
    works = {}
    for e in all_employees:
        for s_id, s_info in shifts.items():
            if s_info['role'] in employees_df[employees_df['Employee_Name'] == e]['Role'].values:
                for d in range(num_days):
                    if days_of_week[d] in s_info['days']:
                        works[(e, s_id, d)] = model.NewBoolVar(f'works_{e}_{s_id}_{d}')

    # --- MERGED: Hard Constraint to Lock Past Days ---
    date_columns = official_schedule_df.columns[1:]
    for d in range(today_index + 1):
        if d < len(date_columns):
            day_col = date_columns[d]
            for _, row in official_schedule_df.iterrows():
                shift_id, official_employee = row['Shift'], row[day_col]
                if official_employee and (official_employee in all_employees):
                    if (official_employee, shift_id, d) in works:
                        model.Add(works[(official_employee, shift_id, d)] == 1)

    # (All other hard constraints remain the same)
    for s_id, s_info in shifts.items():
        for d in range(num_days):
            if days_of_week[d] in s_info['days']:
                model.AddExactlyOne(works.get((e, s_id, d), 0) for e in employees[s_info['role']])
    for e in all_employees:
        for d in range(num_days): model.AddAtMostOne(works.get((e, s_id, d), 0) for s_id in shifts)
    for e in all_employees:
        if e != 'INT1':
            for d in range(num_days - 6):
                worked_days = [works[key] for key in works if key[0] == e and d <= key[2] < d + 7]
                model.Add(sum(worked_days) <= 6)

    # --- MERGED: Objective Function with Hints and Token Bids ---
    request_bonuses = []
    if requests:
      for emp, day, shift_type, penalty in requests:
          day_index = day - 1
          if shift_type == 'OFF':
              is_working_on_day = [works[key] for key in works if key[0] == emp and key[2] == day_index]
              request_fulfilled = model.NewBoolVar(f'request_{emp}_{day_index}')
              model.Add(sum(is_working_on_day) == 0).OnlyEnforceIf(request_fulfilled)
              model.Add(sum(is_working_on_day) > 0).OnlyEnforceIf(request_fulfilled.Not())
              request_bonuses.append(penalty * request_fulfilled)

    hint_bonuses = []
    for d in range(today_index + 1, num_days): # Hinting only for future days
        if d < len(date_columns):
            day_col = date_columns[d]
            for _, row in official_schedule_df.iterrows():
                shift_id, official_employee = row['Shift'], row[day_col]
                if official_employee and (official_employee in all_employees):
                    if (official_employee, shift_id, d) in works:
                        hint_bonuses.append(works[(official_employee, shift_id, d)])

    model.Maximize(sum(request_bonuses) + sum(hint_bonuses))

    # (Solver and return logic remains the same)
    solver = cp_model.CpSolver()
    # Use 4 parallel workers to speed up the search
    solver.parameters.num_search_workers = 4
    status = solver.Solve(model)

    if status in (cp_model.OPTIMAL, cp_model.FEASIBLE):
        print("✅ Schedule generated successfully.")
        solution = {}
        for (e, s, d), var in works.items():
            if solver.Value(var):
                solution[(s, d)] = e
        return solution
    else:
        print("❌ No solution found.")
        return None

# --- MODULE 3: OFFER AND REPLY WORKFLOW ---

def create_and_send_offers(sheet, solution, official_schedule_df, employees_df, requests_df):
    """
    Compares the new solution to the official schedule, identifies changes,
    creates offers, sends them via email, and logs them to the 'Offers' sheet.
    """
    print("--- Creating and Sending Schedule Change Offers ---")

    # First, generate the new schedule DataFrame from the solution
    sandbox_data = {}
    date_columns = official_schedule_df.columns[1:]
    for col in date_columns:
        sandbox_data[col] = []
        day_index = date_columns.get_loc(col)
        for shift_id in official_schedule_df['Shift']:
            employee = solution.get((shift_id, day_index), '')
            sandbox_data[col].append(employee)
    sandbox_df = pd.DataFrame(sandbox_data, index=official_schedule_df['Shift'])

    # --- NEW: Identify the requester(s) whose request was fulfilled ---
    winners = []
    if not requests_df.empty:
        for _, request in requests_df.iterrows():
            emp, day = request['Employee_Name'], pd.to_datetime(request['Start_Date'], dayfirst=True).day
            day_col = official_schedule_df.columns[day]
            is_working = any(sandbox_df.loc[shift_id, day_col] == emp for shift_id in sandbox_df.index)
            if not is_working:
                winners.append(emp)
    # For simplicity, we'll assume the first winner is the primary requester for all changes.
    requester_name = winners[0] if winners else "SYSTEM"

    # Get email credentials
    sender_email = os.environ.get('GMAIL_ADDRESS')
    app_password = os.environ.get('GMAIL_APP_PASSWORD')
    if not sender_email or not app_password:
        print("❌ Email credentials not found. Cannot send offers.")
        return sandbox_df

    offers_ws = sheet.worksheet("Offers")
    offers_to_log = []

    # Find all changes and create one offer per changed day per person
    all_changes = {}
    for day_col in date_columns:
        for shift_id in official_schedule_df['Shift']:
            official_employee = official_schedule_df.loc[official_schedule_df['Shift'] == shift_id, day_col].iloc[0]
            sandbox_employee = sandbox_df.loc[shift_id, day_col]
            official_employee = '' if pd.isna(official_employee) else official_employee
            sandbox_employee = '' if pd.isna(sandbox_employee) else sandbox_employee

            if official_employee != sandbox_employee:
                if official_employee:
                    if official_employee not in all_changes: all_changes[official_employee] = []
                    change_desc = f"On {day_col}, your shift '{shift_id}' was reassigned to {sandbox_employee or 'unassigned'}."
                    all_changes[official_employee].append(change_desc)
                if sandbox_employee:
                    if sandbox_employee not in all_changes: all_changes[sandbox_employee] = []
                    change_desc = f"On {day_col}, you were assigned to shift '{shift_id}' (previously {official_employee or 'unassigned'})."
                    all_changes[sandbox_employee].append(change_desc)

    # Now, create and send one email per employee with all their changes
    for employee_name, changes_list in all_changes.items():
        offer_id = str(uuid.uuid4())
        recipient_email_series = employees_df[employees_df['Employee_Name'] == employee_name]['Email']
        if recipient_email_series.empty:
            print(f"⚠️ Could not find email for {employee_name}. Skipping offer.")
            continue
        recipient_email = recipient_email_series.iloc[0]

        hr_email = "hr.scheduler@example.com"
        accept_subject = f"ACCEPT-{offer_id}"
        decline_subject = f"DECLINE-{offer_id}"
        accept_link = f"mailto:{hr_email}?subject={accept_subject}"
        decline_link = f"mailto:{hr_email}?subject={decline_subject}"

        email_body = (
            f"Hello {employee_name},\n\n"
            f"To accommodate a request from {requester_name}, a change to your schedule has been proposed:\n\n"
            + "\n".join(f"- {change}" for change in changes_list)
            + f"\n\nPlease click to accept or decline:\n"
            f"✅ Accept: {accept_link}\n"
            f"❌ Decline: {decline_link}\n\n"
            f"This offer is valid for 1 hour. Offer ID: {offer_id}"
        )

        msg = EmailMessage()
        msg.set_content(email_body)
        msg['Subject'] = 'Schedule Change Proposal'
        msg['From'] = sender_email
        msg['To'] = recipient_email

        try:
            server = smtplib.SMTP_SSL('smtp.gmail.com', 465)
            server.login(sender_email, app_password)
            server.send_message(msg)
            server.quit()
            print(f"✅ Offer email sent to {employee_name} ({recipient_email}) for Offer ID {offer_id}")

            expiry_time = (datetime.now() + timedelta(hours=1)).strftime('%Y-%m-%d %H:%M:%S')
            # NEW: Log the requester's name
            offers_to_log.append([offer_id, employee_name, "PENDING", expiry_time, requester_name])

        except Exception as e:
            print(f"❌ Failed to send offer email to {employee_name}: {e}")

    if offers_to_log:
        offers_ws.append_rows(offers_to_log)
        print(f"✅ Logged {len(offers_to_log)} new offers to the 'Offers' tab.")

    sandbox_ws = sheet.worksheet("Sandbox_Schedule")
    sandbox_ws.update([sandbox_df.columns.values.tolist()] + sandbox_df.reset_index().values.tolist())
    print("✅ Sandbox_Schedule tab has been updated.")

    return sandbox_df

def process_email_replies(sheet):
    """Logs into the HR inbox and processes replies to offers."""
    print("--- Processing Email Replies ---")
    try:
        hr_email = os.environ.get('GMAIL_ADDRESS')
        app_password = os.environ.get('GMAIL_APP_PASSWORD')
        if not hr_email or not app_password:
            print("❌ HR Email credentials not found. Cannot process replies.")
            return

        offers_ws = sheet.worksheet("Offers")

        mail = imaplib.IMAP4_SSL("imap.gmail.com")
        mail.login(hr_email, app_password)
        mail.select("inbox")

        # Search for unread emails with our specific subject format
        status, data_accept = mail.search(None, '(UNSEEN SUBJECT "ACCEPT-")')
        status, data_decline = mail.search(None, '(UNSEEN SUBJECT "DECLINE-")')

        all_ids = data_accept[0].split() + data_decline[0].split()

        for num in all_ids:
            status, data = mail.fetch(num, '(RFC822)')
            msg = email.message_from_bytes(data[0][1])
            subject = msg['subject']

            try:
                response, offer_id = subject.split('-')
                cell = offers_ws.find(offer_id)
                if cell:
                    offers_ws.update_cell(cell.row, 4, response.upper()) # Update 'Status' column
                    print(f"✅ Processed reply for Offer {offer_id}. Status set to {response.upper()}.")
                    # Mark email as read
                    mail.store(num, '+FLAGS', '\\Seen')
            except Exception as e:
                print(f"⚠️ Could not parse subject: '{subject}'. Error: {e}")

    except Exception as e:
        print(f"❌ An error occurred while processing email replies: {e}")



def finalize_schedule(sheet, official_schedule_df, sandbox_df, employees_df, requests_df):
    """
    Checks offer statuses, reverts changes for failed offers, and notifies requesters.
    """
    print("--- Finalizing Sandbox Schedule Based on Responses ---")
    offers_ws = sheet.worksheet("Offers")
    offer_data = pd.DataFrame(offers_ws.get_all_records())

    # Check for declined or expired offers (PENDING is treated as expired)
    failed_offers = offer_data[offer_data['Status'].isin(['DECLINED', 'PENDING'])]

    if failed_offers.empty:
        print("✅ All offers were accepted. Sandbox is ready for approval.")
        return sandbox_df # Return the confirmed sandbox

    print(f"Found {len(failed_offers)} declined or expired offers. Reverting changes...")

    # Create a mutable copy of the sandbox to revert changes
    final_sandbox_df = sandbox_df.copy()

    failed_requesters = set()

    for _, offer in failed_offers.iterrows():
        original_requester = offer['Requester_Name']
        failed_requesters.add(original_requester)

        # This is a simplified revert logic. It finds all changes associated with the requester
        # and reverts them.
        for day_col in official_schedule_df.columns[1:]:
             for shift_id in official_schedule_df['Shift']:
                official_employee = official_schedule_df.loc[official_schedule_df['Shift'] == shift_id, day_col].iloc[0]
                sandbox_employee = sandbox_df.loc[shift_id, day_col]

                # If this change was caused by the failed request, revert it
                # A more advanced system would link offers to specific changes
                if sandbox_employee != official_employee:
                    final_sandbox_df.loc[shift_id, day_col] = official_employee

    # Batch update the Google Sheet with the reverted schedule
    sandbox_ws = sheet.worksheet("Sandbox_Schedule")
    sandbox_ws.update([final_sandbox_df.columns.values.tolist()] + final_sandbox_df.reset_index().values.tolist())
    print("✅ Sandbox schedule has been updated with reverted changes.")

    # Notify all failed requesters
    for requester in failed_requesters:
        print(f"--> Notifying {requester} that their request could not be fulfilled.")
        # (The email sending logic would be called here)

    return final_sandbox_df

def redistribute_tokens(sheet, requests_df, official_schedule_df, final_sandbox_df):
    """
    Redistributes tokens from winners to affected employees or losing bidders.
    """
    print("--- Starting Token Redistribution ---")

    employees_ws = sheet.worksheet("Employees")
    emp_data = employees_ws.get_all_records()
    token_balances = {row['Employee_Name']: row['Tokens_Official'] for row in emp_data}

    # Identify winners by finding whose OFF request was fulfilled
    winners = []
    if not requests_df.empty:
        for _, request in requests_df.iterrows():
            emp, day = request['Employee_Name'], pd.to_datetime(request['Start_Date'], dayfirst=True).day
            day_col = official_schedule_df.columns[day] # Get column name like '2025-09-02 (Tue)'

            # Check if the employee is working in the sandbox on their requested day off
            is_working = any(final_sandbox_df.loc[shift_id, day_col] == emp for shift_id in final_sandbox_df.index)

            if not is_working:
                winners.append(request)

    if not winners:
        print("No winning requests to process for token redistribution.")
        return

    for winner in winners:
        winner_name = winner['Employee_Name']
        tokens_to_distribute = winner['Tokens_Bid']
        day_of_win = pd.to_datetime(winner['Start_Date'], dayfirst=True).day
        day_col = official_schedule_df.columns[day_of_win]

        print(f"Processing win for {winner_name} on day {day_of_win}. Tokens to redistribute: {tokens_to_distribute}")

        # Deduct tokens from winner
        token_balances[winner_name] -= tokens_to_distribute

        # Priority 1: Find employees whose schedule changed on that day
        changed_employees = []
        for shift_id in official_schedule_df.index:
            official_emp = official_schedule_df.loc[shift_id, day_col]
            sandbox_emp = final_sandbox_df.loc[shift_id, day_col]
            if official_emp != sandbox_emp:
                # Someone whose shift was taken away
                if official_emp and official_emp in token_balances: changed_employees.append(official_emp)
                # Someone who was newly assigned to a shift
                if sandbox_emp and sandbox_emp in token_balances: changed_employees.append(sandbox_emp)

        # Remove the winner from the list of changed employees
        changed_employees = [e for e in set(changed_employees) if e != winner_name]

        if changed_employees:
            print(f"Distributing tokens to changed employees: {changed_employees}")
            tokens_per_person = tokens_to_distribute // len(changed_employees)
            for emp in changed_employees:
                token_balances[emp] += tokens_per_person
        else:
            # Priority 2: No one's schedule changed, find losing bidders for that day
            losing_bidders = []
            for _, request in requests_df.iterrows():
                req_day = pd.to_datetime(request['Start_Date'], dayfirst=True).day
                # A loser is someone who requested the same day off but isn't the winner
                if req_day == day_of_win and request['Employee_Name'] != winner_name:
                    losing_bidders.append(request['Employee_Name'])

            if losing_bidders:
                print(f"Distributing tokens to losing bidders: {losing_bidders}")
                tokens_per_person = tokens_to_distribute // len(losing_bidders)
                for emp in losing_bidders:
                    token_balances[emp] += tokens_per_person

    # Batch update the token balances in the Google Sheet
    employees_to_update = employees_ws.col_values(1)
    cell_updates = []
    for emp_name, new_balance in token_balances.items():
        try:
            row_index = employees_to_update.index(emp_name) + 1
            # Column D is Tokens_Official, F is Tokens_Sandbox. Let's update both.
            cell_updates.append(gspread.Cell(row_index, 4, new_balance))
            cell_updates.append(gspread.Cell(row_index, 6, new_balance))
        except ValueError:
            continue

    if cell_updates:
        employees_ws.update_cells(cell_updates)
        print("✅ Token balances have been updated in the Google Sheet.")

# --- Main script execution ---
if __name__ == '__main__':
    hr_sheet = connect_to_sheet()
    if hr_sheet:
        employees_df, shifts_df, requests_df, official_schedule_df = read_data(hr_sheet)
        
        new_solution = generate_schedule(employees_df, shifts_df, requests_df, official_schedule_df)
        
        if new_solution:
            sandbox_df = create_and_send_offers(hr_sheet, new_solution, official_schedule_df, employees_df, requests_df)

            print("--- Waiting for 1 hour for employees to respond... ---")
            time.sleep(3600)

            process_email_replies(hr_sheet)

            final_sandbox_df = finalize_schedule(hr_sheet, official_schedule_df, sandbox_df, employees_df, requests_df)

            redistribute_tokens(hr_sheet, requests_df, official_schedule_df, final_sandbox_df)
