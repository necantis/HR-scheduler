# -*- coding: utf-8 -*-
"""HR_Scheduling with Github.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1KhTmrJkw043HKJIJ3Kz2eE3Wai_Ou-rP
"""

import gspread
from oauth2client.service_account import ServiceAccountCredentials
import pandas as pd

def connect_to_sheet():
    """
    Connects to the Google Sheet using the credentials file.

    Returns:
        gspread.Spreadsheet: The spreadsheet object.
    """
    try:
        scope = ['https://spreadsheets.google.com/feeds',
                 'https://www.googleapis.com/auth/drive']
        creds = ServiceAccountCredentials.from_json_keyfile_name('creds.json', scope)
        client = gspread.authorize(creds)
        spreadsheet = client.open('2025_HR Planner')
        print("✅ Successfully connected to the Google Sheet.")
        return spreadsheet
    except Exception as e:
        print(f"❌ Error connecting to Google Sheet: {e}")
        return None

# --- NEW FUNCTIONS START HERE ---

def read_employees(sheet):
    """Reads the Employees tab into a pandas DataFrame."""
    print("Reading employee data...")
    worksheet = sheet.worksheet("Employees")
    data = worksheet.get_all_records()
    return pd.DataFrame(data)

def read_shifts(sheet):
    """Reads the Shifts tab into a pandas DataFrame."""
    print("Reading shift definitions...")
    worksheet = sheet.worksheet("Shifts")
    data = worksheet.get_all_records()
    return pd.DataFrame(data)

def read_requests(sheet):
    """Reads the Absence_Requests tab into a pandas DataFrame."""
    print("Reading absence requests...")
    # Note the use of the French column names you specified.
    worksheet = sheet.worksheet("Absence_Requests")
    data = worksheet.get_all_records()
    df = pd.DataFrame(data)
    # Ensure the column names in the script match your sheet
    df = df.rename(columns={"Nom": "Employee_Name", "Date": "Requested_Date", "Tokens": "Tokens_Bid"})
    return df

# --- Main script execution ---
if __name__ == '__main__':
    # Step 1: Connect to our spreadsheet
    hr_sheet = connect_to_sheet()

    if hr_sheet:
        # Step 2: Read data from the tabs
        employees_df = read_employees(hr_sheet)
        shifts_df = read_shifts(hr_sheet)
        requests_df = read_requests(hr_sheet)

        # Print the data to verify it was read correctly
        print("\n--- Data Read from Google Sheet ---")
        print("\nEmployees:")
        print(employees_df)
        print("\nShifts:")
        print(shifts_df)
        print("\nAbsence Requests:")
        print(requests_df)
        print("\n------------------------------------")

import gspread
from oauth2client.service_account import ServiceAccountCredentials
import pandas as pd
from datetime import datetime, timedelta
from ortools.sat.python import cp_model

# --- MODULE 1: GOOGLE SHEETS CONNECTION & DATA READING ---

def connect_to_sheet():
    """Connects to the Google Sheet."""
    try:
        scope = ['https://spreadsheets.google.com/feeds', 'https://www.googleapis.com/auth/drive']
        creds = ServiceAccountCredentials.from_json_keyfile_name('creds.json', scope)
        client = gspread.authorize(creds)
        spreadsheet = client.open('2025_HR Planner')
        print("✅ Successfully connected to the Google Sheet.")
        return spreadsheet
    except Exception as e:
        print(f"❌ Error connecting to Google Sheet: {e}")
        return None

def read_data(sheet):
    """Reads all required data from the Google Sheet into DataFrames."""
    print("Reading data from all tabs...")
    employees_ws = sheet.worksheet("Employees")
    employees_df = pd.DataFrame(employees_ws.get_all_records())

    shifts_ws = sheet.worksheet("Shifts")
    shifts_df = pd.DataFrame(shifts_ws.get_all_records())

    requests_ws = sheet.worksheet("Absence_Requests")
    requests_df = pd.DataFrame(requests_ws.get_all_records())
    if not requests_df.empty:
        requests_df = requests_df.rename(columns={"Nom": "Employee_Name", "Date": "Requested_Date", "Tokens": "Tokens_Bid"})
    
    official_schedule_ws = sheet.worksheet("Official_Schedule")
    official_schedule_df = pd.DataFrame(official_schedule_ws.get_all_records())

    return employees_df, shifts_df, requests_df, official_schedule_df

# --- MODULE 2: SCHEDULING LOGIC (OR-TOOLS) ---

def generate_schedule(employees_df, shifts_df, requests_df, official_schedule_df):
    """
    Generates a schedule, using the official schedule as a hint and locking past days.
    """
    print("--- Starting Schedule Generation (with hints from Official Schedule) ---")

    # --- STEP 1: DATA PREPARATION (Same as before) ---
    all_employees = employees_df['Employee_Name'].tolist()
    employees = {'Infirmier': [], 'Intérimaire': []}
    for _, row in employees_df.iterrows():
        name, role = row['Employee_Name'], row['Role']
        if role in employees: employees[role].append(name)

    shifts = {}
    for _, row in shifts_df.iterrows():
        shift_id = row['Shift_ID']
        applicable_days = [int(day) for day in str(row['Applicable_Days'])]
        shifts[shift_id] = {'duration': int(row['Duration_Hours'] * 100), 'role': row['Role'], 'days': applicable_days}
    
    requests = []
    if not requests_df.empty:
        for _, row in requests_df.iterrows():
            date_obj = pd.to_datetime(row['Requested_Date'], dayfirst=True)
            day_of_month = date_obj.day
            requests.append((row['Employee_Name'], day_of_month, 'OFF', row['Tokens_Bid']))

    # --- NEW: Get today's date to lock past days ---
    # In a real run, this is today. For testing, we can pretend it's Sept 3rd.
    # today = datetime.now()
    today = datetime(2025, 9, 3)
    today_index = today.day - 1 # Day 3 corresponds to index 2

    # --- STEP 2: CREATE THE MODEL AND VARIABLES (Same as before) ---
    num_days = 30
    days_of_week = [d % 7 for d in range(num_days)]
    model = cp_model.CpModel()
    works = {}
    for e in all_employees:
        for s_id, s_info in shifts.items():
            if s_info['role'] in employees_df[employees_df['Employee_Name'] == e]['Role'].values:
                for d in range(num_days):
                    if days_of_week[d] in s_info['days']:
                        works[(e, s_id, d)] = model.NewBoolVar(f'works_{e}_{s_id}_{d}')

    # --- STEP 3: ADD THE CONSTRAINTS (with new locking logic) ---

    # --- NEW: Lock all shifts for past and present days ---
    print(f"Locking all shifts on and before Day {today.day}...")
    date_columns = official_schedule_df.columns[1:]
    for d in range(today_index + 1):
        day_col = date_columns[d]
        for _, row in official_schedule_df.iterrows():
            shift_id = row['Shift']
            official_employee = row[day_col]
            if official_employee and (official_employee in all_employees):
                # This shift must be assigned to this person
                if (official_employee, shift_id, d) in works:
                    model.Add(works[(official_employee, shift_id, d)] == 1)
                # All other people cannot be assigned to this shift
                for e in all_employees:
                    if e != official_employee and (e, shift_id, d) in works:
                        model.Add(works[(e, shift_id, d)] == 0)

    # (All other hard constraints remain the same: coverage, 6-day work week, etc.)
    for s_id, s_info in shifts.items():
        for d in range(num_days):
            if days_of_week[d] in s_info['days']:
                model.AddExactlyOne(works.get((e, s_id, d), 0) for e in employees[s_info['role']])
    for e in all_employees:
        for d in range(num_days): model.AddAtMostOne(works.get((e, s_id, d), 0) for s_id in shifts)
    for e in all_employees:
        if e != 'INT1':
            for d in range(num_days - 6):
                worked_days = [works[key] for key in works if key[0] == e and d <= key[2] < d + 7]
                model.Add(sum(worked_days) <= 6)

    # --- STEP 4: DEFINE THE OBJECTIVE FUNCTION (with new hinting logic) ---
    
    # Primary objective: Fulfill high-token requests
    request_bonuses = []
    if requests:
      for emp, day, shift_type, penalty in requests:
          day_index = day - 1
          if shift_type == 'OFF':
              is_working_on_day = [works[key] for key in works if key[0] == emp and key[2] == day_index]
              request_fulfilled = model.NewBoolVar(f'request_{emp}_{day_index}')
              model.Add(sum(is_working_on_day) == 0).OnlyEnforceIf(request_fulfilled)
              model.Add(sum(is_working_on_day) > 0).OnlyEnforceIf(request_fulfilled.Not())
              request_bonuses.append(penalty * request_fulfilled)

    # --- NEW: Secondary objective: Prefer sticking to the official schedule ---
    hint_bonuses = []
    date_columns = official_schedule_df.columns[1:] # Re-get date_columns just in case
    for d in range(today_index + 1, num_days): # Only for future days
        day_col = date_columns[d]
        for _, row in official_schedule_df.iterrows():
            shift_id = row['Shift']
            official_employee = row[day_col]
            if official_employee and (official_employee in all_employees):
                if (official_employee, shift_id, d) in works:
                    # Add a small bonus (e.g., 1 point) for keeping this assignment
                    hint_bonuses.append(works[(official_employee, shift_id, d)])

    # Combine the objectives. Fulfilling a request (worth its token value) is much
    # more important than sticking to the old schedule (worth 1 point).
    model.Maximize(sum(request_bonuses) + sum(hint_bonuses))

    # --- STEP 5 & 6: SOLVE AND RETURN (Same as before) ---
    solver = cp_model.CpSolver()
    status = solver.Solve(model)

    if status in (cp_model.OPTIMAL, cp_model.FEASIBLE):
        print("✅ Schedule generated successfully.")
        solution = {}
        for (e, s, d), var in works.items():
            if solver.Value(var):
                solution[(s, d)] = e
        return solution
    else:
        print("❌ No solution found.")
        return None

# --- MODULE 3: WRITE, COMPARE, AND NOTIFY ---

import os
import smtplib
from email.message import EmailMessage

# --- NEW EMAIL FUNCTION ---
def send_notification_email(summary_message, affected_employees, employees_df):
    """Sends the summary message to affected employees."""
    print("--- Preparing to Send Email Notification ---")
    try:
        # Get credentials from GitHub Secrets (environment variables)
        sender_email = os.environ.get('GMAIL_ADDRESS')
        app_password = os.environ.get('GMAIL_APP_PASSWORD')

        if not sender_email or not app_password:
            print("❌ Email credentials not found. Skipping email.")
            return

        # Find the email addresses of the affected employees
        recipient_emails = employees_df[employees_df['Employee_Name'].isin(affected_employees)]['Email'].tolist()

        if not recipient_emails:
            print("No affected employees with emails found. Skipping email.")
            return

        # Create the email message
        msg = EmailMessage()
        msg.set_content(summary_message.replace('**', '')) # Remove markdown for plain text
        msg['Subject'] = 'New Schedule Proposal Ready for Review'
        msg['From'] = sender_email
        msg['To'] = ", ".join(recipient_emails)

        # Connect to Gmail's server and send the email
        server = smtplib.SMTP_SSL('smtp.gmail.com', 465)
        server.login(sender_email, app_password)
        server.send_message(msg)
        server.quit()

        print(f"✅ Email notification sent successfully to: {', '.join(recipient_emails)}")

    except Exception as e:
        print(f"❌ Failed to send email: {e}")

def update_sandbox_and_compare(sheet, solution, official_schedule_df):
    """Writes to the sandbox, compares it to the official, and generates a clean summary."""
    print("--- Updating Sandbox & Comparing Schedules ---")
    
    sandbox_ws = sheet.worksheet("Sandbox_Schedule")
    
    sandbox_data = {}
    date_columns = official_schedule_df.columns[1:]
    for col in date_columns:
        sandbox_data[col] = []
        day_index = date_columns.get_loc(col)
        for shift_id in official_schedule_df['Shift']:
            employee = solution.get((shift_id, day_index), '')
            sandbox_data[col].append(employee)
            
    sandbox_df = pd.DataFrame(sandbox_data, index=official_schedule_df['Shift'])
    
    sandbox_ws.update([sandbox_df.columns.values.tolist()] + sandbox_df.values.tolist(), value_input_option='USER_ENTERED')
    print("✅ Sandbox_Schedule tab has been updated.")

    changes = []
    affected_employees = set()
    for day_col in date_columns:
        day_changes = []
        for shift_id in official_schedule_df['Shift']:
            # Use .get() to avoid errors if a column/row name is weird
            official_employee = official_schedule_df.loc[official_schedule_df['Shift'] == shift_id, day_col].iloc[0]
            sandbox_employee = sandbox_df.loc[shift_id, day_col]
            
            # Convert blank values to a consistent empty string for comparison
            official_employee = '' if pd.isna(official_employee) or official_employee in ['(blank)', '...'] else official_employee
            sandbox_employee = '' if pd.isna(sandbox_employee) else sandbox_employee

            # --- IMPROVEMENT HERE ---
            # Only report a change if the values are actually different
            if str(official_employee) != str(sandbox_employee):
                # Make the output cleaner
                from_text = f"'{official_employee}'" if official_employee else "empty"
                to_text = f"**'{sandbox_employee}'**" if sandbox_employee else "**empty**"
                
                day_changes.append(f"* **Shift {shift_id}:** Changed from {from_text} to {to_text}")
                
                # Add employees to the affected list
                if official_employee: affected_employees.add(official_employee)
                if sandbox_employee: affected_employees.add(sandbox_employee)
        
        if day_changes:
            changes.append(f"**Changes for {day_col}:**\n" + "\n".join(day_changes))

    if changes:
        summary_message = (
            "**Subject: New Schedule Proposal Ready for Review**\n\n"
            "A new schedule has been generated in the sandbox based on recent requests.\n\n"
            "**Summary of Changes:**\n\n" + "\n\n".join(changes) + "\n\n"
            f"**Affected Employees:** {', '.join(sorted(list(affected_employees)))}\n\n"
            "Please review the `Sandbox_Schedule` tab. The HR manager will make it official after approval."
        )
    else:
        summary_message = "**Subject: No Changes in New Schedule**\n\nNo changes were necessary in today's schedule run."
        
    print("\n--- Notification Summary ---")
    print(summary_message)

    return summary_message, affected_employees, sandbox_df


# --- NEW TOKEN REDISTRIBUTION MODULE ---

def redistribute_tokens(sheet, requests_df, official_schedule_df, sandbox_df):
    """
    Redistributes tokens from winners to affected employees or losing bidders.
    """
    print("--- Starting Token Redistribution ---")

    employees_ws = sheet.worksheet("Employees")
    emp_data = employees_ws.get_all_records()
    token_balances = {row['Employee_Name']: row['Tokens_Official'] for row in emp_data}

    # Identify winners by finding whose OFF request was fulfilled
    winners = []
    if not requests_df.empty:
        for _, request in requests_df.iterrows():
            emp, day = request['Employee_Name'], pd.to_datetime(request['Requested_Date'], dayfirst=True).day
            day_col = official_schedule_df.columns[day] # Get column name like '2025-09-02 (Tue)'

            # Check if the employee is working in the sandbox on their requested day off
            is_working = any(sandbox_df.loc[shift_id, day_col] == emp for shift_id in sandbox_df.index)

            if not is_working:
                winners.append(request)

    if not winners:
        print("No winning requests to process for token redistribution.")
        return

    for winner in winners:
        winner_name = winner['Employee_Name']
        tokens_to_distribute = winner['Tokens_Bid']
        day_of_win = pd.to_datetime(winner['Requested_Date'], dayfirst=True).day
        day_col = official_schedule_df.columns[day_of_win]

        print(f"Processing win for {winner_name} on day {day_of_win}. Tokens to redistribute: {tokens_to_distribute}")

        # Deduct tokens from winner
        token_balances[winner_name] -= tokens_to_distribute

        # Priority 1: Find employees whose schedule changed on that day
        changed_employees = []
        for shift_id in official_schedule_df.index:
            official_emp = official_schedule_df.loc[shift_id, day_col]
            sandbox_emp = sandbox_df.loc[shift_id, day_col]
            if official_emp != sandbox_emp:
                # Someone whose shift was taken away
                if official_emp and official_emp in token_balances: changed_employees.append(official_emp)
                # Someone who was newly assigned to a shift
                if sandbox_emp and sandbox_emp in token_balances: changed_employees.append(sandbox_emp)

        # Remove the winner from the list of changed employees
        changed_employees = [e for e in set(changed_employees) if e != winner_name]

        if changed_employees:
            print(f"Distributing tokens to changed employees: {changed_employees}")
            tokens_per_person = tokens_to_distribute // len(changed_employees)
            for emp in changed_employees:
                token_balances[emp] += tokens_per_person
        else:
            # Priority 2: No one's schedule changed, find losing bidders for that day
            losing_bidders = []
            for _, request in requests_df.iterrows():
                req_day = pd.to_datetime(request['Requested_Date'], dayfirst=True).day
                # A loser is someone who requested the same day off but isn't the winner
                if req_day == day_of_win and request['Employee_Name'] != winner_name:
                    losing_bidders.append(request['Employee_Name'])

            if losing_bidders:
                print(f"Distributing tokens to losing bidders: {losing_bidders}")
                tokens_per_person = tokens_to_distribute // len(losing_bidders)
                for emp in losing_bidders:
                    token_balances[emp] += tokens_per_person

    # Batch update the token balances in the Google Sheet
    employees_to_update = employees_ws.col_values(1)
    cell_updates = []
    for emp_name, new_balance in token_balances.items():
        try:
            row_index = employees_to_update.index(emp_name) + 1
            # Column D is Tokens_Official, F is Tokens_Sandbox. Let's update both.
            cell_updates.append(gspread.Cell(row_index, 4, new_balance))
            cell_updates.append(gspread.Cell(row_index, 6, new_balance))
        except ValueError:
            continue

    if cell_updates:
        employees_ws.update_cells(cell_updates)
        print("✅ Token balances have been updated in the Google Sheet.")

# --- Main script execution ---
if __name__ == '__main__':
    hr_sheet = connect_to_sheet()
    if hr_sheet:
        employees_df, shifts_df, requests_df, official_schedule_df = read_data(hr_sheet)
        
        new_solution = generate_schedule(employees_df, shifts_df, requests_df, official_schedule_df)
        
        if new_solution:
            summary_message, affected_employees, sandbox_df = update_sandbox_and_compare(hr_sheet, new_solution, official_schedule_df)

            redistribute_tokens(hr_sheet, requests_df, official_schedule_df, sandbox_df)

            send_notification_email(summary_message, affected_employees, employees_df)
