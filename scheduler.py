# -*- coding: utf-8 -*-
"""HR_Scheduling with Github.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1KhTmrJkw043HKJIJ3Kz2eE3Wai_Ou-rP
"""

pip install gspread oauth2client ortools

import gspread
from oauth2client.service_account import ServiceAccountCredentials
import pandas as pd

def connect_to_sheet():
    """
    Connects to the Google Sheet using the credentials file.

    Returns:
        gspread.Spreadsheet: The spreadsheet object.
    """
    try:
        scope = ['https://spreadsheets.google.com/feeds',
                 'https://www.googleapis.com/auth/drive']
        creds = ServiceAccountCredentials.from_json_keyfile_name('creds.json', scope)
        client = gspread.authorize(creds)
        spreadsheet = client.open('2025_HR Planner')
        print("✅ Successfully connected to the Google Sheet.")
        return spreadsheet
    except Exception as e:
        print(f"❌ Error connecting to Google Sheet: {e}")
        return None

# --- NEW FUNCTIONS START HERE ---

def read_employees(sheet):
    """Reads the Employees tab into a pandas DataFrame."""
    print("Reading employee data...")
    worksheet = sheet.worksheet("Employees")
    data = worksheet.get_all_records()
    return pd.DataFrame(data)

def read_shifts(sheet):
    """Reads the Shifts tab into a pandas DataFrame."""
    print("Reading shift definitions...")
    worksheet = sheet.worksheet("Shifts")
    data = worksheet.get_all_records()
    return pd.DataFrame(data)

def read_requests(sheet):
    """Reads the Absence_Requests tab into a pandas DataFrame."""
    print("Reading absence requests...")
    # Note the use of the French column names you specified.
    worksheet = sheet.worksheet("Absence_Requests")
    data = worksheet.get_all_records()
    df = pd.DataFrame(data)
    # Ensure the column names in the script match your sheet
    df = df.rename(columns={"Nom": "Employee_Name", "Date": "Requested_Date", "Tokens": "Tokens_Bid"})
    return df

# --- Main script execution ---
if __name__ == '__main__':
    # Step 1: Connect to our spreadsheet
    hr_sheet = connect_to_sheet()

    if hr_sheet:
        # Step 2: Read data from the tabs
        employees_df = read_employees(hr_sheet)
        shifts_df = read_shifts(hr_sheet)
        requests_df = read_requests(hr_sheet)

        # Print the data to verify it was read correctly
        print("\n--- Data Read from Google Sheet ---")
        print("\nEmployees:")
        print(employees_df)
        print("\nShifts:")
        print(shifts_df)
        print("\nAbsence Requests:")
        print(requests_df)
        print("\n------------------------------------")

# (Keep all previous code: connect_to_sheet, read_employees, etc.)
# ...

from ortools.sat.python import cp_model
import pandas as pd
from datetime import datetime, timedelta

def generate_and_write_schedule(hr_sheet, employees_df, shifts_df, requests_df):
    """
    Generates a schedule and writes it directly to the Google Sheet.
    """
    print("\n--- Starting Schedule Generation ---")

    # --- STEP 1: CONVERT DATAFRAMES TO OR-TOOLS FORMAT ---
    # (This section remains the same as the previous version)
    all_employees = employees_df['Employee_Name'].tolist()
    employees = {'Infirmier': [], 'Intérimaire': []}
    for index, row in employees_df.iterrows():
        name = row['Employee_Name']
        role = row['Role']
        if role in employees: employees[role].append(name)

    shifts = {}
    for index, row in shifts_df.iterrows():
        shift_id = row['Shift_ID']
        applicable_days = [int(day) for day in str(row['Applicable_Days'])]
        shifts[shift_id] = {'duration': int(row['Duration_Hours'] * 100), 'role': row['Role'], 'days': applicable_days}

    requests = []
    for index, row in requests_df.iterrows():
        date_obj = pd.to_datetime(row['Requested_Date'], dayfirst=True)
        day_of_month = date_obj.day
        requests.append((row['Employee_Name'], day_of_month, 'OFF', row['Tokens_Bid']))

    num_days = 30
    days_of_week = [d % 7 for d in range(num_days)]

    # --- STEP 2: CREATE THE MODEL AND VARIABLES ---
    # (This section remains the same)
    model = cp_model.CpModel()
    works = {}
    for e in all_employees:
        for s_id, s_info in shifts.items():
            if s_info['role'] in employees_df[employees_df['Employee_Name'] == e]['Role'].values:
                for d in range(num_days):
                    if days_of_week[d] in s_info['days']:
                        works[(e, s_id, d)] = model.NewBoolVar(f'works_{e}_{s_id}_{d}')

    # --- STEP 3: ADD THE CONSTRAINTS ---
    # (This section remains the same)
    for s_id, s_info in shifts.items():
        for d in range(num_days):
            if days_of_week[d] in s_info['days']:
                model.AddExactlyOne(works.get((e, s_id, d), 0) for e in employees[s_info['role']])
    for e in all_employees:
        for d in range(num_days): model.AddAtMostOne(works.get((e, s_id, d), 0) for s_id in shifts)
    for e in all_employees:
        if e != 'INT1':
            for d in range(num_days - 6):
                worked_days = [works[key] for key in works if key[0] == e and d <= key[2] < d + 7]
                model.Add(sum(worked_days) <= 6)

    # --- STEP 4: DEFINE THE OBJECTIVE FUNCTION ---
    # (This section remains the same)
    request_bonuses = []
    for emp, day, shift_type, penalty in requests:
        day_index = day - 1
        if shift_type == 'OFF':
            is_working_on_day = [works[key] for key in works if key[0] == emp and key[2] == day_index]
            request_fulfilled = model.NewBoolVar(f'request_{emp}_{day_index}')
            model.Add(sum(is_working_on_day) == 0).OnlyEnforceIf(request_fulfilled)
            model.Add(sum(is_working_on_day) > 0).OnlyEnforceIf(request_fulfilled.Not())
            request_bonuses.append(penalty * request_fulfilled)

    model.Maximize(sum(request_bonuses))

    # --- STEP 5: SOLVE THE MODEL ---
    solver = cp_model.CpSolver()
    status = solver.Solve(model)

    # --- STEP 6: WRITE THE SOLUTION TO GOOGLE SHEET ---
    if status == cp_model.OPTIMAL or status == cp_model.FEASIBLE:
        print("✅ Solution Found! Writing schedule to Google Sheet...")

        schedule_ws = hr_sheet.worksheet("Schedule")

        # Prepare data for batch update
        # Get the start date from your header, e.g., '2025-09-01 (Mon)'
        start_date_str = schedule_ws.cell(1, 2).value.split(' ')[0]
        start_date = datetime.strptime(start_date_str, '%Y-%m-%d')

        update_cells = []

        # Create a list of Shift IDs to find the row number
        shift_ids = shifts_df['Shift_ID'].tolist()

        for d in range(num_days):
            col_index = d + 2 # Column B is 2, C is 3, etc.
            current_date = start_date + timedelta(days=d)

            # Update header to ensure it's correct
            day_name = current_date.strftime('%a')
            date_header = f"{current_date.strftime('%Y-%m-%d')} ({day_name})"
            update_cells.append(gspread.Cell(1, col_index, date_header))

            for s_id in shifts:
                if days_of_week[d] in shifts[s_id]['days']:
                    row_index = shift_ids.index(s_id) + 2 # Row 2 is H, 3 is I1, etc.
                    assigned_employee = ''
                    for e in all_employees:
                        if (e, s_id, d) in works and solver.Value(works[(e, s_id, d)]):
                            assigned_employee = e
                            break
                    update_cells.append(gspread.Cell(row_index, col_index, assigned_employee))

        # Perform the batch update
        schedule_ws.update_cells(update_cells)
        print("✅ Schedule tab has been updated.")

        # --- UPDATE TOKEN BALANCES ---
        employees_ws = hr_sheet.worksheet("Employees")
        employee_names = employees_ws.col_values(1) # Get all names from column A

        for emp, day, shift_type, tokens in requests:
            day_index = day - 1
            is_working = any(solver.Value(works.get((emp, s_id, day_index), 0)) for s_id in shifts)

            if not is_working: # Request was fulfilled
                print(f"Fulfilled request for {emp}. Deducting {tokens} tokens.")
                try:
                    row_index = employee_names.index(emp) + 1
                    current_tokens = int(employees_ws.cell(row_index, 4).value)
                    new_balance = current_tokens - tokens
                    employees_ws.update_cell(row_index, 4, new_balance)
                except ValueError:
                    print(f"Warning: Could not find employee {emp} to update tokens.")

        print("✅ Token balances have been updated.")

    else:
        print("\n❌ No solution found.")


# --- Main script execution ---
if __name__ == '__main__':
    hr_sheet = connect_to_sheet()

    if hr_sheet:
        employees_df = read_employees(hr_sheet)
        shifts_df = read_shifts(hr_sheet)
        requests_df = read_requests(hr_sheet)

        # Call the final function
        generate_and_write_schedule(hr_sheet, employees_df, shifts_df, requests_df)