# -*- coding: utf-8 -*-
"""HR_Scheduling with Github.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1KhTmrJkw043HKJIJ3Kz2eE3Wai_Ou-rP
"""

import gspread
from oauth2client.service_account import ServiceAccountCredentials
import pandas as pd

def connect_to_sheet():
    """
    Connects to the Google Sheet using the credentials file.

    Returns:
        gspread.Spreadsheet: The spreadsheet object.
    """
    try:
        scope = ['https://spreadsheets.google.com/feeds',
                 'https://www.googleapis.com/auth/drive']
        creds = ServiceAccountCredentials.from_json_keyfile_name('creds.json', scope)
        client = gspread.authorize(creds)
        spreadsheet = client.open('2025_HR Planner')
        print("✅ Successfully connected to the Google Sheet.")
        return spreadsheet
    except Exception as e:
        print(f"❌ Error connecting to Google Sheet: {e}")
        return None

# --- NEW FUNCTIONS START HERE ---

def read_employees(sheet):
    """Reads the Employees tab into a pandas DataFrame."""
    print("Reading employee data...")
    worksheet = sheet.worksheet("Employees")
    data = worksheet.get_all_records()
    return pd.DataFrame(data)

def read_shifts(sheet):
    """Reads the Shifts tab into a pandas DataFrame."""
    print("Reading shift definitions...")
    worksheet = sheet.worksheet("Shifts")
    data = worksheet.get_all_records()
    return pd.DataFrame(data)

def read_requests(sheet):
    """Reads the Absence_Requests tab into a pandas DataFrame."""
    print("Reading absence requests...")
    # Note the use of the French column names you specified.
    worksheet = sheet.worksheet("Absence_Requests")
    data = worksheet.get_all_records()
    df = pd.DataFrame(data)
    # Ensure the column names in the script match your sheet
    df = df.rename(columns={"Nom": "Employee_Name", "Date": "Requested_Date", "Tokens": "Tokens_Bid"})
    return df

# --- Main script execution ---
if __name__ == '__main__':
    # Step 1: Connect to our spreadsheet
    hr_sheet = connect_to_sheet()

    if hr_sheet:
        # Step 2: Read data from the tabs
        employees_df = read_employees(hr_sheet)
        shifts_df = read_shifts(hr_sheet)
        requests_df = read_requests(hr_sheet)

        # Print the data to verify it was read correctly
        print("\n--- Data Read from Google Sheet ---")
        print("\nEmployees:")
        print(employees_df)
        print("\nShifts:")
        print(shifts_df)
        print("\nAbsence Requests:")
        print(requests_df)
        print("\n------------------------------------")

import gspread
from oauth2client.service_account import ServiceAccountCredentials
import pandas as pd
from datetime import datetime, timedelta, date
import calendar
from ortools.sat.python import cp_model
import uuid
import imaplib
import email
import time

# --- MODULE 1: GOOGLE SHEETS CONNECTION & DATA READING ---

def connect_to_sheet():
    """Connects to the Google Sheet."""
    try:
        scope = ['https://spreadsheets.google.com/feeds', 'https://www.googleapis.com/auth/drive']
        creds = ServiceAccountCredentials.from_json_keyfile_name('creds.json', scope)
        client = gspread.authorize(creds)
        spreadsheet = client.open('2025_HR Planner')
        print("✅ Successfully connected to the Google Sheet.")
        return spreadsheet
    except Exception as e:
        print(f"❌ Error connecting to Google Sheet: {e}")
        return None

def read_data(sheet):
    """Reads all required data from the Google Sheet into DataFrames."""
    print("Reading data from all tabs...")
    employees_ws = sheet.worksheet("Employees")
    employees_df = pd.DataFrame(employees_ws.get_all_records())

    shifts_ws = sheet.worksheet("Shifts")
    shifts_df = pd.DataFrame(shifts_ws.get_all_records())

    requests_ws = sheet.worksheet("Absence_Requests")
    requests_df = pd.DataFrame(requests_ws.get_all_records())
    if not requests_df.empty:
        # Use the new French column names "Début" and "Fin"
        requests_df = requests_df.rename(columns={
            "Nom": "Employee_Name",
            "Début": "Start_Date",
            "Fin": "End_Date",
            "Tokens": "Tokens_Bid"
        })
    
    official_schedule_ws = sheet.worksheet("Official_Schedule")
    official_schedule_df = pd.DataFrame(official_schedule_ws.get_all_records())

    return employees_df, shifts_df, requests_df, official_schedule_df

# --- MODULE 2: SCHEDULING LOGIC (OR-TOOLS) ---

def generate_schedule(employees_df, shifts_df, requests_df, official_schedule_df):
    """
    Generates a schedule with ALL features: dynamic dates, multi-day requests,
    locking past days, and using the official schedule as a hint.
    """
    print("--- Starting Schedule Generation (Full-Featured) ---")

    # --- MERGED: Dynamic Date & Multi-Day Request Logic ---
    today = datetime.now()
    _, num_days = calendar.monthrange(today.year, today.month)
    today_index = today.day - 1
    print(f"✅ Detected {num_days} days for the current month. Locking all days up to and including Day {today.day}.")

    requests = []
    if not requests_df.empty:
        for _, row in requests_df.iterrows():
            start_date = pd.to_datetime(row['Start_Date'], dayfirst=True)
            end_date = pd.to_datetime(row['End_Date'], dayfirst=True)
            num_request_days = (end_date - start_date).days + 1
            tokens_per_day = row['Tokens_Bid'] // num_request_days if num_request_days > 0 else 0
            for day_delta in range(num_request_days):
                current_date = start_date + timedelta(days=day_delta)
                requests.append((row['Employee_Name'], current_date.day, 'OFF', tokens_per_day))

    # (The rest of the data prep remains the same)
    all_employees = employees_df['Employee_Name'].tolist()
    employees = {'Infirmier': [], 'Intérimaire': []}
    for _, row in employees_df.iterrows():
        name, role = row['Employee_Name'], row['Role']
        if role in employees: employees[role].append(name)

    shifts = {}
    for _, row in shifts_df.iterrows():
        shift_id = row['Shift_ID']
        applicable_days = [int(day) for day in str(row['Applicable_Days'])]
        shifts[shift_id] = {'duration': int(row['Duration_Hours'] * 100), 'role': row['Role'], 'days': applicable_days}
    
    days_of_week = [d % 7 for d in range(num_days)]
    model = cp_model.CpModel()
    works = {}
    for e in all_employees:
        for s_id, s_info in shifts.items():
            if s_info['role'] in employees_df[employees_df['Employee_Name'] == e]['Role'].values:
                for d in range(num_days):
                    if days_of_week[d] in s_info['days']:
                        works[(e, s_id, d)] = model.NewBoolVar(f'works_{e}_{s_id}_{d}')

    # --- MERGED: Hard Constraint to Lock Past Days ---
    date_columns = official_schedule_df.columns[1:]
    for d in range(today_index + 1):
        if d < len(date_columns):
            day_col = date_columns[d]
            for _, row in official_schedule_df.iterrows():
                shift_id, official_employee = row['Shift'], row[day_col]
                if official_employee and (official_employee in all_employees):
                    if (official_employee, shift_id, d) in works:
                        model.Add(works[(official_employee, shift_id, d)] == 1)

    # (All other hard constraints remain the same)
    for s_id, s_info in shifts.items():
        for d in range(num_days):
            if days_of_week[d] in s_info['days']:
                model.AddExactlyOne(works.get((e, s_id, d), 0) for e in employees[s_info['role']])
    for e in all_employees:
        for d in range(num_days): model.AddAtMostOne(works.get((e, s_id, d), 0) for s_id in shifts)
    for e in all_employees:
        if e != 'INT1':
            for d in range(num_days - 6):
                worked_days = [works[key] for key in works if key[0] == e and d <= key[2] < d + 7]
                model.Add(sum(worked_days) <= 6)

    # --- MERGED: Objective Function with Hints and Token Bids ---
    request_bonuses = []
    if requests:
      for emp, day, shift_type, penalty in requests:
          day_index = day - 1
          if shift_type == 'OFF':
              is_working_on_day = [works[key] for key in works if key[0] == emp and key[2] == day_index]
              request_fulfilled = model.NewBoolVar(f'request_{emp}_{day_index}')
              model.Add(sum(is_working_on_day) == 0).OnlyEnforceIf(request_fulfilled)
              model.Add(sum(is_working_on_day) > 0).OnlyEnforceIf(request_fulfilled.Not())
              request_bonuses.append(penalty * request_fulfilled)

    hint_bonuses = []
    for d in range(today_index + 1, num_days): # Hinting only for future days
        if d < len(date_columns):
            day_col = date_columns[d]
            for _, row in official_schedule_df.iterrows():
                shift_id, official_employee = row['Shift'], row[day_col]
                if official_employee and (official_employee in all_employees):
                    if (official_employee, shift_id, d) in works:
                        hint_bonuses.append(works[(official_employee, shift_id, d)])

    model.Maximize(sum(request_bonuses) + sum(hint_bonuses))

    # (Solver and return logic remains the same)
    solver = cp_model.CpSolver()
    status = solver.Solve(model)

    if status in (cp_model.OPTIMAL, cp_model.FEASIBLE):
        print("✅ Schedule generated successfully.")
        solution = {}
        for (e, s, d), var in works.items():
            if solver.Value(var):
                solution[(s, d)] = e
        return solution
    else:
        print("❌ No solution found.")
        return None

# --- MODULE 3: OFFER AND REPLY WORKFLOW ---

def create_and_send_offers(sheet, solution, official_schedule_df, employees_df):
    """
    Compares the new solution to the official schedule, identifies changes,
    creates offers, sends them via email, and logs them to the 'Offers' sheet.
    """
    print("--- Creating and Sending Schedule Change Offers ---")

    # First, generate the new schedule DataFrame from the solution
    sandbox_data = {}
    date_columns = official_schedule_df.columns[1:]
    for col in date_columns:
        sandbox_data[col] = []
        day_index = date_columns.get_loc(col)
        for shift_id in official_schedule_df['Shift']:
            employee = solution.get((shift_id, day_index), '')
            sandbox_data[col].append(employee)
    sandbox_df = pd.DataFrame(sandbox_data, index=official_schedule_df['Shift'])

    # Get email credentials
    sender_email = os.environ.get('GMAIL_ADDRESS')
    app_password = os.environ.get('GMAIL_APP_PASSWORD')
    if not sender_email or not app_password:
        print("❌ Email credentials not found. Cannot send offers.")
        return sandbox_df # Return the sandbox_df anyway

    offers_ws = sheet.worksheet("Offers")
    offers_to_log = []

    # Find all changes and create one offer per changed day per person
    all_changes = {} # Key: employee_name, Value: list of change strings
    for day_col in date_columns:
        for shift_id in official_schedule_df['Shift']:
            official_employee = official_schedule_df.loc[official_schedule_df['Shift'] == shift_id, day_col].iloc[0]
            sandbox_employee = sandbox_df.loc[shift_id, day_col]
            official_employee = '' if pd.isna(official_employee) else official_employee
            sandbox_employee = '' if pd.isna(sandbox_employee) else sandbox_employee

            if official_employee != sandbox_employee:
                # Change involving the official employee (shift taken away)
                if official_employee:
                    if official_employee not in all_changes: all_changes[official_employee] = []
                    change_desc = f"On {day_col}, your shift '{shift_id}' was reassigned to {sandbox_employee or 'unassigned'}."
                    all_changes[official_employee].append(change_desc)
                # Change involving the sandbox employee (new shift assigned)
                if sandbox_employee:
                    if sandbox_employee not in all_changes: all_changes[sandbox_employee] = []
                    change_desc = f"On {day_col}, you were assigned to shift '{shift_id}' (previously {official_employee or 'unassigned'})."
                    all_changes[sandbox_employee].append(change_desc)

    # Now, create and send one email per employee with all their changes
    for employee_name, changes_list in all_changes.items():
        offer_id = str(uuid.uuid4())
        
        # Get recipient email
        recipient_email_series = employees_df[employees_df['Employee_Name'] == employee_name]['Email']
        if recipient_email_series.empty:
            print(f"⚠️ Could not find email for {employee_name}. Skipping offer.")
            continue
        recipient_email = recipient_email_series.iloc[0]

        # Create email content
        hr_email = "hr.scheduler@example.com"
        accept_subject = f"ACCEPT-{offer_id}"
        decline_subject = f"DECLINE-{offer_id}"
        accept_link = f"mailto:{hr_email}?subject={accept_subject}"
        decline_link = f"mailto:{hr_email}?subject={decline_subject}"

        email_body = (
            f"Hello {employee_name},\n\nA change to your schedule has been proposed:\n\n"
            + "\n".join(f"- {change}" for change in changes_list)
            + f"\n\nPlease click to accept or decline:\n"
            f"✅ Accept: {accept_link}\n"
            f"❌ Decline: {decline_link}\n\n"
            f"This offer is valid for 1 hour. Offer ID: {offer_id}"
        )
        
        # Send the email
        msg = EmailMessage()
        msg.set_content(email_body)
        msg['Subject'] = 'Schedule Change Proposal'
        msg['From'] = sender_email
        msg['To'] = recipient_email

        try:
            server = smtplib.SMTP_SSL('smtp.gmail.com', 465)
            server.login(sender_email, app_password)
            server.send_message(msg)
            server.quit()
            print(f"✅ Offer email sent to {employee_name} ({recipient_email}) for Offer ID {offer_id}")

            # Log the offer to the sheet
            expiry_time = (datetime.now() + timedelta(hours=1)).strftime('%Y-%m-%d %H:%M:%S')
            offers_to_log.append([offer_id, employee_name, "PENDING", expiry_time])

        except Exception as e:
            print(f"❌ Failed to send offer email to {employee_name}: {e}")

    if offers_to_log:
        offers_ws.append_rows(offers_to_log)
        print(f"✅ Logged {len(offers_to_log)} new offers to the 'Offers' tab.")

    # Also update the sandbox sheet for HR review
    sandbox_ws = sheet.worksheet("Sandbox_Schedule")
    sandbox_ws.update([sandbox_df.columns.values.tolist()] + sandbox_df.reset_index().values.tolist())
    print("✅ Sandbox_Schedule tab has been updated.")

    return sandbox_df

def process_email_replies(sheet):
    """Logs into the HR inbox and processes replies to offers."""
    print("--- Processing Email Replies ---")
    try:
        hr_email = os.environ.get('GMAIL_ADDRESS')
        app_password = os.environ.get('GMAIL_APP_PASSWORD')
        if not hr_email or not app_password:
            print("❌ HR Email credentials not found. Cannot process replies.")
            return

        offers_ws = sheet.worksheet("Offers")

        mail = imaplib.IMAP4_SSL("imap.gmail.com")
        mail.login(hr_email, app_password)
        mail.select("inbox")

        # Search for unread emails with our specific subject format
        status, data_accept = mail.search(None, '(UNSEEN SUBJECT "ACCEPT-")')
        status, data_decline = mail.search(None, '(UNSEEN SUBJECT "DECLINE-")')

        all_ids = data_accept[0].split() + data_decline[0].split()

        for num in all_ids:
            status, data = mail.fetch(num, '(RFC822)')
            msg = email.message_from_bytes(data[0][1])
            subject = msg['subject']

            try:
                response, offer_id = subject.split('-')
                cell = offers_ws.find(offer_id)
                if cell:
                    offers_ws.update_cell(cell.row, 4, response.upper()) # Update 'Status' column
                    print(f"✅ Processed reply for Offer {offer_id}. Status set to {response.upper()}.")
                    # Mark email as read
                    mail.store(num, '+FLAGS', '\\Seen')
            except Exception as e:
                print(f"⚠️ Could not parse subject: '{subject}'. Error: {e}")

    except Exception as e:
        print(f"❌ An error occurred while processing email replies: {e}")



# --- Main script execution ---
if __name__ == '__main__':
    hr_sheet = connect_to_sheet()
    if hr_sheet:
        employees_df, shifts_df, requests_df, official_schedule_df = read_data(hr_sheet)
        
        new_solution = generate_schedule(employees_df, shifts_df, requests_df, official_schedule_df)
        
        if new_solution:
            sandbox_df = create_and_send_offers(hr_sheet, new_solution, official_schedule_df, employees_df)

            print("--- Waiting for 1 hour for employees to respond... ---")
            time.sleep(3600) # Wait for 3600 seconds (1 hour)

            process_email_replies(hr_sheet)

            # ... (Finalize the schedule based on the new offer statuses) ...
