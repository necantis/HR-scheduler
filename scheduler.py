# -*- coding: utf-8 -*-
"""HR_Scheduling with Github.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1KhTmrJkw043HKJIJ3Kz2eE3Wai_Ou-rP
"""

import gspread
from oauth2client.service_account import ServiceAccountCredentials
import pandas as pd

def connect_to_sheet():
    """
    Connects to the Google Sheet using the credentials file.

    Returns:
        gspread.Spreadsheet: The spreadsheet object.
    """
    try:
        scope = ['https://spreadsheets.google.com/feeds',
                 'https://www.googleapis.com/auth/drive']
        creds = ServiceAccountCredentials.from_json_keyfile_name('creds.json', scope)
        client = gspread.authorize(creds)
        spreadsheet = client.open('2025_HR Planner')
        print("✅ Successfully connected to the Google Sheet.")
        return spreadsheet
    except Exception as e:
        print(f"❌ Error connecting to Google Sheet: {e}")
        return None

# --- NEW FUNCTIONS START HERE ---

def read_employees(sheet):
    """Reads the Employees tab into a pandas DataFrame."""
    print("Reading employee data...")
    worksheet = sheet.worksheet("Employees")
    data = worksheet.get_all_records()
    return pd.DataFrame(data)

def read_shifts(sheet):
    """Reads the Shifts tab into a pandas DataFrame."""
    print("Reading shift definitions...")
    worksheet = sheet.worksheet("Shifts")
    data = worksheet.get_all_records()
    return pd.DataFrame(data)

def read_requests(sheet):
    """Reads the Absence_Requests tab into a pandas DataFrame."""
    print("Reading absence requests...")
    # Note the use of the French column names you specified.
    worksheet = sheet.worksheet("Absence_Requests")
    data = worksheet.get_all_records()
    df = pd.DataFrame(data)
    # Ensure the column names in the script match your sheet
    df = df.rename(columns={"Nom": "Employee_Name", "Date": "Requested_Date", "Tokens": "Tokens_Bid"})
    return df

# --- Main script execution ---
if __name__ == '__main__':
    # Step 1: Connect to our spreadsheet
    hr_sheet = connect_to_sheet()

    if hr_sheet:
        # Step 2: Read data from the tabs
        employees_df = read_employees(hr_sheet)
        shifts_df = read_shifts(hr_sheet)
        requests_df = read_requests(hr_sheet)

        # Print the data to verify it was read correctly
        print("\n--- Data Read from Google Sheet ---")
        print("\nEmployees:")
        print(employees_df)
        print("\nShifts:")
        print(shifts_df)
        print("\nAbsence Requests:")
        print(requests_df)
        print("\n------------------------------------")

import gspread
from oauth2client.service_account import ServiceAccountCredentials
import pandas as pd
from datetime import datetime, timedelta
from ortools.sat.python import cp_model

# --- MODULE 1: GOOGLE SHEETS CONNECTION & DATA READING ---

def connect_to_sheet():
    """Connects to the Google Sheet."""
    try:
        scope = ['https://spreadsheets.google.com/feeds', 'https://www.googleapis.com/auth/drive']
        creds = ServiceAccountCredentials.from_json_keyfile_name('creds.json', scope)
        client = gspread.authorize(creds)
        spreadsheet = client.open('2025_HR Planner')
        print("✅ Successfully connected to the Google Sheet.")
        return spreadsheet
    except Exception as e:
        print(f"❌ Error connecting to Google Sheet: {e}")
        return None

def read_data(sheet):
    """Reads all required data from the Google Sheet into DataFrames."""
    print("Reading data from all tabs...")
    employees_ws = sheet.worksheet("Employees")
    employees_df = pd.DataFrame(employees_ws.get_all_records())

    shifts_ws = sheet.worksheet("Shifts")
    shifts_df = pd.DataFrame(shifts_ws.get_all_records())

    requests_ws = sheet.worksheet("Absence_Requests")
    requests_df = pd.DataFrame(requests_ws.get_all_records())
    if not requests_df.empty:
        requests_df = requests_df.rename(columns={"Nom": "Employee_Name", "Date": "Requested_Date", "Tokens": "Tokens_Bid"})
    
    official_schedule_ws = sheet.worksheet("Official_Schedule")
    official_schedule_df = pd.DataFrame(official_schedule_ws.get_all_records())

    return employees_df, shifts_df, requests_df, official_schedule_df

# --- MODULE 2: SCHEDULING LOGIC (OR-TOOLS) ---

def generate_schedule(employees_df, shifts_df, requests_df):
    """Generates a new schedule based on the input data."""
    print("--- Starting Schedule Generation ---")
    all_employees = employees_df['Employee_Name'].tolist()
    employees = {'Infirmier': [], 'Intérimaire': []}
    for _, row in employees_df.iterrows():
        name, role = row['Employee_Name'], row['Role']
        if role in employees: employees[role].append(name)

    shifts = {}
    for _, row in shifts_df.iterrows():
        shift_id = row['Shift_ID']
        applicable_days = [int(day) for day in str(row['Applicable_Days'])]
        shifts[shift_id] = {'duration': int(row['Duration_Hours'] * 100), 'role': row['Role'], 'days': applicable_days}
    
    requests = []
    if not requests_df.empty:
        for _, row in requests_df.iterrows():
            date_obj = pd.to_datetime(row['Requested_Date'], dayfirst=True)
            day_of_month = date_obj.day
            requests.append((row['Employee_Name'], day_of_month, 'OFF', row['Tokens_Bid']))

    num_days = 30
    days_of_week = [d % 7 for d in range(num_days)]
    model = cp_model.CpModel()
    works = {}
    for e in all_employees:
        for s_id, s_info in shifts.items():
            if s_info['role'] in employees_df[employees_df['Employee_Name'] == e]['Role'].values:
                for d in range(num_days):
                    if days_of_week[d] in s_info['days']:
                        works[(e, s_id, d)] = model.NewBoolVar(f'works_{e}_{s_id}_{d}')

    for s_id, s_info in shifts.items():
        for d in range(num_days):
            if days_of_week[d] in s_info['days']:
                model.AddExactlyOne(works.get((e, s_id, d), 0) for e in employees[s_info['role']])
    for e in all_employees:
        for d in range(num_days): model.AddAtMostOne(works.get((e, s_id, d), 0) for s_id in shifts)
    for e in all_employees:
        if e != 'INT1':
            for d in range(num_days - 6):
                worked_days = [works[key] for key in works if key[0] == e and d <= key[2] < d + 7]
                model.Add(sum(worked_days) <= 6)
    
    request_bonuses = []
    if requests:
      for emp, day, shift_type, penalty in requests:
          day_index = day - 1
          if shift_type == 'OFF':
              is_working_on_day = [works[key] for key in works if key[0] == emp and key[2] == day_index]
              request_fulfilled = model.NewBoolVar(f'request_{emp}_{day_index}')
              model.Add(sum(is_working_on_day) == 0).OnlyEnforceIf(request_fulfilled)
              model.Add(sum(is_working_on_day) > 0).OnlyEnforceIf(request_fulfilled.Not())
              request_bonuses.append(penalty * request_fulfilled)
      model.Maximize(sum(request_bonuses))
    
    solver = cp_model.CpSolver()
    status = solver.Solve(model)

    if status in (cp_model.OPTIMAL, cp_model.FEASIBLE):
        print("✅ Schedule generated successfully.")
        solution = {}
        for (e, s, d), var in works.items():
            if solver.Value(var):
                solution[(s, d)] = e
        return solution
    else:
        print("❌ No solution found.")
        return None

# --- MODULE 3: WRITE, COMPARE, AND NOTIFY ---

import os
import smtplib
from email.message import EmailMessage

# --- NEW EMAIL FUNCTION ---
def send_notification_email(summary_message, affected_employees, employees_df):
    """Sends the summary message to affected employees."""
    print("--- Preparing to Send Email Notification ---")
    try:
        # Get credentials from GitHub Secrets (environment variables)
        sender_email = os.environ.get('GMAIL_ADDRESS')
        app_password = os.environ.get('GMAIL_APP_PASSWORD')

        if not sender_email or not app_password:
            print("❌ Email credentials not found. Skipping email.")
            return

        # Find the email addresses of the affected employees
        recipient_emails = employees_df[employees_df['Employee_Name'].isin(affected_employees)]['Email'].tolist()

        if not recipient_emails:
            print("No affected employees with emails found. Skipping email.")
            return

        # Create the email message
        msg = EmailMessage()
        msg.set_content(summary_message.replace('**', '')) # Remove markdown for plain text
        msg['Subject'] = 'New Schedule Proposal Ready for Review'
        msg['From'] = sender_email
        msg['To'] = ", ".join(recipient_emails)

        # Connect to Gmail's server and send the email
        server = smtplib.SMTP_SSL('smtp.gmail.com', 465)
        server.login(sender_email, app_password)
        server.send_message(msg)
        server.quit()

        print(f"✅ Email notification sent successfully to: {', '.join(recipient_emails)}")

    except Exception as e:
        print(f"❌ Failed to send email: {e}")

def update_sandbox_and_compare(sheet, solution, official_schedule_df):
    """Writes to the sandbox, compares it to the official, and generates a clean summary."""
    print("--- Updating Sandbox & Comparing Schedules ---")
    
    sandbox_ws = sheet.worksheet("Sandbox_Schedule")
    
    sandbox_data = {}
    date_columns = official_schedule_df.columns[1:]
    for col in date_columns:
        sandbox_data[col] = []
        day_index = date_columns.get_loc(col)
        for shift_id in official_schedule_df['Shift']:
            employee = solution.get((shift_id, day_index), '')
            sandbox_data[col].append(employee)
            
    sandbox_df = pd.DataFrame(sandbox_data, index=official_schedule_df['Shift'])
    
    sandbox_ws.update([sandbox_df.columns.values.tolist()] + sandbox_df.values.tolist(), value_input_option='USER_ENTERED')
    print("✅ Sandbox_Schedule tab has been updated.")

    changes = []
    affected_employees = set()
    for day_col in date_columns:
        day_changes = []
        for shift_id in official_schedule_df['Shift']:
            # Use .get() to avoid errors if a column/row name is weird
            official_employee = official_schedule_df.loc[official_schedule_df['Shift'] == shift_id, day_col].iloc[0]
            sandbox_employee = sandbox_df.loc[shift_id, day_col]
            
            # Convert blank values to a consistent empty string for comparison
            official_employee = '' if pd.isna(official_employee) or official_employee in ['(blank)', '...'] else official_employee
            sandbox_employee = '' if pd.isna(sandbox_employee) else sandbox_employee

            # --- IMPROVEMENT HERE ---
            # Only report a change if the values are actually different
            if str(official_employee) != str(sandbox_employee):
                # Make the output cleaner
                from_text = f"'{official_employee}'" if official_employee else "empty"
                to_text = f"**'{sandbox_employee}'**" if sandbox_employee else "**empty**"
                
                day_changes.append(f"* **Shift {shift_id}:** Changed from {from_text} to {to_text}")
                
                # Add employees to the affected list
                if official_employee: affected_employees.add(official_employee)
                if sandbox_employee: affected_employees.add(sandbox_employee)
        
        if day_changes:
            changes.append(f"**Changes for {day_col}:**\n" + "\n".join(day_changes))

    if changes:
        summary_message = (
            "**Subject: New Schedule Proposal Ready for Review**\n\n"
            "A new schedule has been generated in the sandbox based on recent requests.\n\n"
            "**Summary of Changes:**\n\n" + "\n\n".join(changes) + "\n\n"
            f"**Affected Employees:** {', '.join(sorted(list(affected_employees)))}\n\n"
            "Please review the `Sandbox_Schedule` tab. The HR manager will make it official after approval."
        )
    else:
        summary_message = "**Subject: No Changes in New Schedule**\n\nNo changes were necessary in today's schedule run."
        
    print("\n--- Notification Summary ---")
    print(summary_message)

    return summary_message, affected_employees

# --- Main script execution ---
if __name__ == '__main__':
    hr_sheet = connect_to_sheet()
    if hr_sheet:
        employees_df, shifts_df, requests_df, official_schedule_df = read_data(hr_sheet)
        
        new_solution = generate_schedule(employees_df, shifts_df, requests_df)
        
        if new_solution:
            # The compare function now also returns the list of affected people
            summary_message, affected_employees = update_sandbox_and_compare(hr_sheet, new_solution, official_schedule_df)

            # Send the email
            send_notification_email(summary_message, affected_employees, employees_df)
